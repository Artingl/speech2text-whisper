import json
import os.path
import sys
import threading
import time
from multiprocessing import Process, Queue
from threading import Thread

import pygame
import cv2
import win32gui

from ffpyplayer.player import MediaPlayer
from dateutil import parser

from transcribing import run_transcribing_parallel


class Player:
    def __init__(self, video_file, scale=1.0, language='ru', subtitles_type='json', subtitles_file=None):
        self.lock = threading.Lock()
        self.use_preprocessed_subtitles = subtitles_file is not None

        self.draw_thread = Thread(target=self.draw, daemon=True)
        self.subtitles = Subtitles(subtitles_type, subtitles_file, self)

        self.video_file = video_file
        self.window_scale = scale
        self.language = language

        self.engine_initialized = False
        self.is_paused = False
        self.is_running = False
        self.is_drawing = True

        self.global_font = None
        self.video = None
        self.window = None
        self.clock = None
        self.audio_player = None

        self.video_length = -1
        self.hwnd = -1
        self.video_time = -1
        self.video_framerate = -1
        self.video_width = -1
        self.video_height = -1
        self.width = -1
        self.height = -1

        self.draw_thread_id = None
        self.video_time_tasks = []

        assert self.init_engine()

        if self.use_preprocessed_subtitles:
            print("Using preprocessed subtitles")
            self.subtitles.load_subtitles()
        else:
            print("Using autogenerated subtitles")

            self.transcribing_queue = Queue()
            self.transcribing_process = Process(
                target=run_transcribing_parallel,
                args=(self.transcribing_queue, video_file, language,)
            )

    def run(self):
        if not self.use_preprocessed_subtitles:
            print("Waiting for transcribing to start...")
            self.transcribing_process.start()
            while len(self.subtitles.subtitles) == 0:
                self.subtitles.fetch()
        self.draw_thread.start()
        self.main_loop()

    def reset(self):
        self.video_time = 0

    def init_engine(self):
        if self.engine_initialized:
            print("Engine initialized")
            return False

        print("Initializing engine")
        pygame.init()

        self.video = cv2.VideoCapture(self.video_file)
        self.video_time = 0

        self.video_width = self.video.get(cv2.CAP_PROP_FRAME_WIDTH)
        self.video_height = self.video.get(cv2.CAP_PROP_FRAME_HEIGHT)
        self.video_framerate = self.video.get(cv2.CAP_PROP_FPS)
        self.video_length = self.video.get(cv2.CAP_PROP_FRAME_COUNT) / self.video_framerate

        print(
            f"Video info: framerate - {self.video_framerate}, resolution - {self.video_width}x{self.video_height}")
        print(f"Scaling factor: {self.window_scale}")

        self.width = self.video_width * self.window_scale
        self.height = self.video_height * self.window_scale

        self.clock = pygame.time.Clock()
        self.global_font = pygame.font.SysFont(None, 30)

        self.reset_window()
        self.reset_audio_player()

        self.video_time = 0
        self.engine_initialized = True

        return True

    def set_video_time(self, sec):
        if not self.engine_initialized:
            print("Engine is not initialized")
            return False

        if sec < 0:
            sec = 0

        # This function must be called only from the draw thread.
        # If it was called from other thread, add pending task to the pool
        if threading.get_ident() != self.draw_thread_id:
            self.video_time_tasks.append(sec)
            return True

        self.video_time = sec * 1000
        self.video.set(cv2.CAP_PROP_POS_FRAMES, self.video_framerate * sec)
        self.reset_audio_player()
        self.audio_player.seek(sec)
        self.audio_player.set_pause(False)
        return True

    def reset_window(self):
        # todo: if resizable flag is set, the app will crash when you try to resize the window.
        self.window = pygame.display.set_mode((self.width, self.height))  # , pygame.RESIZABLE)
        self.hwnd = pygame.display.get_wm_info()['window']

    def reset_audio_player(self):
        if self.audio_player is not None:
            self.audio_player.close_player()

        self.audio_player = MediaPlayer(self.video_file)
        self.audio_player.set_pause(True)
        time.sleep(0.1)

    def draw(self):
        print("Drawing")
        self.clock.tick(self.video_framerate)
        self.set_video_time(0)

        self.draw_thread_id = threading.get_ident()

        while self.video.isOpened() and self.is_drawing:
            if self.is_paused:
                info_image = self.global_font.render("PAUSED", True, (255, 255, 255))
                self.window.blit(
                    info_image,
                    (
                        (self.width - info_image.get_width()) / 2,
                        (self.height - info_image.get_height()) / 2
                    )
                )

                self.clock.tick(self.video_framerate)
                pygame.display.flip()
                continue

            # Check if there are any pending tasks from other threads
            if len(self.video_time_tasks) > 0:
                self.lock.acquire()
                for i in self.video_time_tasks:
                    self.set_video_time(i)
                self.video_time_tasks = []
                self.lock.release()

            _, cv_image = self.video.read()
            if cv_image is None:
                continue

            audio_frame, _ = self.audio_player.get_frame()
            pg_image = Player.cvimage_to_pygame(cv_image)

            self.window.blit(pygame.transform.scale(pg_image, (self.width, self.height)), (0, 0))

            speaker, subtitle_info = self.subtitles.get_subtitle_lines(self.video_time / 1000)
            subtitle_y_offset = 0

            info_image = self.global_font.render(f"time: {round(self.video_time / 1000, 2)}, "
                                                 f"FPS: {round(self.clock.get_fps(), 1)}, "
                                                 f"DICT: {len(self.subtitles.subtitles)}, "
                                                 f"SPEAKER: {speaker}", True, (255, 255, 255))
            self.window.blit(info_image, (self.width - info_image.get_width() - 10, 30))

            for subtitle_image in subtitle_info[1]:
                subt_w, subt_h = subtitle_image.get_size()
                subt_x, subt_y = (self.width - subt_w) / 2, \
                                 self.height * 0.8 - subt_h + subtitle_y_offset - subtitle_info[0] / 2

                pygame.draw.rect(self.window, (0, 0, 0), (subt_x, subt_y, subt_w, subt_h))
                self.window.blit(subtitle_image, (subt_x, subt_y))

                subtitle_y_offset += subt_h

            pygame.display.flip()
            pygame.display.update()
            self.video_time += self.clock.tick(self.video_framerate)

    def main_loop(self):
        self.audio_player.set_pause(False)
        self.is_running = True
        self.is_drawing = True
        self.is_paused = False

        while self.is_running:
            self.handle_events()

    def handle_events(self):
        self.window_continue(self.hwnd)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.exit()
            if event.type == pygame.VIDEORESIZE:
                self.lock.acquire()
                self.width = event.w
                self.height = event.h
                self.reset_window()
                pygame.display.update()
                self.lock.release()
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_SPACE:
                    # Pause flag flipped here
                    self.is_paused = not self.is_paused
                    self.audio_player.set_pause(self.is_paused)
                elif event.key == pygame.K_LEFT:
                    # Rewind 5 seconds
                    self.set_video_time(self.video_time / 1000 - 5)
                elif event.key == pygame.K_RIGHT:
                    # Fast-forward 5 seconds
                    self.set_video_time(self.video_time / 1000 + 5)

    def exit(self):
        self.is_running = False
        self.is_drawing = False

        if not self.use_preprocessed_subtitles:
            self.transcribing_process.kill()

        print("Waiting for draw thread...")
        while self.draw_thread.is_alive():
            pass

        pygame.quit()
        sys.exit(0)

    @classmethod
    def cvimage_to_pygame(cls, image):
        """Convert cvimage into a pygame image"""
        return pygame.image.frombuffer(image.tobytes(), image.shape[1::-1],
                                       "BGR")

    @classmethod
    def window_continue(cls, hwnd):
        """Allows to update the Window when dragging with mouse"""
        message = win32gui.GetMessage(hwnd, 0, 0)

        if message[0] != 0:
            win32gui.TranslateMessage(message[1])
            win32gui.DispatchMessage(message[1])


class Subtitles:
    def __init__(self, subtitles_type, subtitles_file, player: Player):
        self.player = player

        self.subtitles = []
        self.subtitles_file = subtitles_file
        self.subtitles_type = subtitles_type

    def load_subtitles(self):
        print("Loading subtitles...", end=' ')

        if not os.path.isfile(self.subtitles_file):
            print(f"file '{self.subtitles_file}' not found")
            return False

        if self.subtitles_type == "text":
            with open(self.subtitles_file, "rb") as file:
                self.subtitles = self.prepare_subtitles_array(file.read().decode("utf-8").split("\n"))
        elif self.subtitles_type == "json":
            self.subtitles = self.prepare_subtitles_array(json.load(open(self.subtitles_file, "rb")))
        else:
            print(f"invalid subtitles type {self.subtitles_type}")
            return False
        print("done")

        return True

    @classmethod
    def get_timestamp(cls, time_str):
        colons = time_str.count(":")
        for _ in range(2 - colons):
            time_str = f"00:{time_str}"

        return parser.parse(time_str).timestamp()

    def prepare_subtitles_array(self, values):
        result = []

        if self.subtitles_type == "text":
            filter_time = -1

            for row in values:
                since_time = Subtitles.get_timestamp(row.split("[")[1].split("--")[0].strip())
                expire_time = Subtitles.get_timestamp(row.split(">")[1].split("]")[0].strip())

                if filter_time == -1:
                    filter_time = since_time

                since_time -= filter_time
                expire_time -= filter_time

                result.append(
                    (
                        since_time,
                        expire_time,
                        self.format_subtitle_string(row.split("]")[1].strip())
                    )
                )
        elif self.subtitles_type == "json":
            for i in values:
                i['text'] = self.format_subtitle_string(i['text'])
                result.append(i)

        return result

    def format_subtitle_string(self, s):
        lines = []
        line = ""
        font_height = 0

        for i in s.split(" "):
            f_width = self.player.global_font.size(line + i + " ")[0]

            if f_width > self.player.width * 0.7:
                lines.append(self.player.global_font.render(line, True, (255, 255, 255)))
                font_height += lines[-1].get_height()
                line = ""
            else:
                line += i + " "

        if line != "":
            lines.append(self.player.global_font.render(line, True, (255, 255, 255)))
            font_height += lines[-1].get_height()

        return font_height, lines

    def get_subtitle_lines(self, vtime):
        if not self.player.use_preprocessed_subtitles:
            self.fetch()

        if self.subtitles_type == "text":
            # Find suitable subtitle row
            row = list(filter(lambda x: x[0] <= vtime <= x[1], self.subtitles))

            if len(row) == 0:
                return -1, (0, [])

            return -1, row[0][2]
        elif self.subtitles_type == "json":
            # Find suitable subtitle row
            row = list(filter(lambda x: x["start"] <= vtime <= x["end"], self.subtitles))

            if len(row) == 0:
                return -1, (0, [])

            return -1, row[0]["text"]

        return -1, (0, [])

    def add_segment(self, segment):
        segment_copy = segment.copy()
        segment_copy['text'] = self.format_subtitle_string(segment_copy['text'])
        self.subtitles.append(segment_copy)

    def fetch(self):
        try:
            while value := self.player.transcribing_queue.get(False):
                self.add_segment(value)
        except:
            pass
            # Will raise queue.Empty, if no data available


if __name__ == '__main__':
    player = Player("video.mp4", scale=0.8, language='en')
    player.run()
